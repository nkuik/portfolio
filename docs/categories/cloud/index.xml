<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cloud on Home</title><link>https://nathankuik.com/categories/cloud/</link><description>Recent content in Cloud on Home</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 02 Jun 2021 08:00:00 +0100</lastBuildDate><atom:link href="https://nathankuik.com/categories/cloud/index.xml" rel="self" type="application/rss+xml"/><item><title>Automated Mobile iOS &amp; Android Builds using Fastlane and CircleCI</title><link>https://nathankuik.com/posts/automating-mobile-app-builds-releases/</link><pubDate>Wed, 02 Jun 2021 08:00:00 +0100</pubDate><guid>https://nathankuik.com/posts/automating-mobile-app-builds-releases/</guid><description>&lt;p&gt;I was recently tasked with automating the iOS and Android build and releases at
my work last month. We had some compliance checks coming up, and instead of
making 2+ dev machines a part of the audit process, the decision was made to
fully automate the build and release process.&lt;/p&gt;
&lt;p&gt;After doing some initial digging, I realized that there was a bit more to it
than I had first thought, primarily due to the fact that the current process
involved a designated individual from each team doing a manual clean build and
upload, using shared certificates and keys. While it was theoretically possible
that the compliance check could audit the existing process (e.g., dev machines),
it would be less than ideal.&lt;/p&gt;</description></item><item><title>Terraformed AWS API Gateway Lambda Function with Custom Domain</title><link>https://nathankuik.com/posts/terraform-aws-api-gateway-lambda/</link><pubDate>Sun, 18 Apr 2021 12:00:00 +0100</pubDate><guid>https://nathankuik.com/posts/terraform-aws-api-gateway-lambda/</guid><description>&lt;h2 id="api-gateway-v1-rest-vs-v2-websocket-and-http"&gt;
 API Gateway V1 (REST) vs. V2 (Websocket and HTTP)
 &lt;a class="heading-link" href="#api-gateway-v1-rest-vs-v2-websocket-and-http"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;I was setting up a Lambda Function that sat behind a specific route of an API Gateway the other day at work, instead of setting up a microservice on a Kubernetes cluster and dealing with the ingress/deployment setup. While I was able to find specific pieces of this setup out there on the interwebs, I didn&amp;rsquo;t find an end-to-end solution that just worked &amp;ldquo;out of the box.&amp;rdquo; This post shows how to create the following using Terraform:&lt;/p&gt;</description></item><item><title>The Kubernetes Threshold</title><link>https://nathankuik.com/posts/kubernetes-threshold/</link><pubDate>Fri, 15 Jan 2021 08:00:00 +0100</pubDate><guid>https://nathankuik.com/posts/kubernetes-threshold/</guid><description>&lt;h2 id="a-single-server"&gt;
 A Single Server
 &lt;a class="heading-link" href="#a-single-server"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Let’s imagine a small server running an application out in the wild. The
application is small&amp;ndash;it requires only a backend server, a database, and some
static frontend code&amp;ndash;but despite its size, the traffic on this server has been
increasing in the last few weeks.&lt;/p&gt;
&lt;p&gt;As the traffic continues to grow, response times grow slower and users begin
complaining about the application’s slowness. Thankful that the application is
seeing increased traffic, the main developer of the application uses a late
night to increase CPU and memory on the server (a vertical scale), which
succeeds without issue.&lt;/p&gt;</description></item></channel></rss>